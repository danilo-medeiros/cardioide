/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/chart/chart.js":
/*!****************************!*\
  !*** ./src/chart/chart.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _basicMathFunctions = __webpack_require__(/*! ./../math/basic-math-functions */ \"./src/math/basic-math-functions.js\");\n\nvar _basicMathFunctions2 = _interopRequireDefault(_basicMathFunctions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Chart = function () {\n  function Chart(parentDiv) {\n    _classCallCheck(this, Chart);\n\n    var childNodes = parentDiv.childNodes;\n\n    this.parentDiv = parentDiv;\n\n    // Circunferência do centro e linhas do gráfico\n    this.canvas1 = childNodes[1];\n\n    // Circunferência que traslada\n    this.canvas2 = childNodes[3];\n\n    // Curva\n    this.canvas3 = childNodes[5];\n\n    this.center = [this.parentDiv.offsetWidth * 0.75, this.parentDiv.offsetHeight * 0.75];\n    this.basicMathFunctions = new _basicMathFunctions2.default();\n\n    this.scale = 100;\n    this.configure();\n    this.drawChart();\n\n    this.unityX = 1;\n    this.unityY = 1;\n  }\n\n  _createClass(Chart, [{\n    key: \"configure\",\n    value: function configure() {\n\n      this.canvas1.width = this.canvas2.width = this.canvas3.width = this.defaultWidth = this.parentDiv.offsetWidth * 1.5;\n      this.canvas1.height = this.canvas2.height = this.canvas3.height = this.defaultHeight = this.parentDiv.offsetHeight * 1.5;\n\n      this.ctx1 = this.canvas1.getContext(\"2d\");\n      this.ctx2 = this.canvas2.getContext(\"2d\");\n      this.ctx3 = this.canvas3.getContext(\"2d\");\n\n      this.ctx1.lineWidth = this.ctx2.lineWidth = this.ctx3.lineWidth = 4 / this.scale;\n      this.ctx1.font = this.ctx2.font = this.ctx3.font = \"italic 1px Helvetica\";\n      //this.ctx1.textAlign = this.ctx2.textAlign = this.ctx3.textAlign = \"center\";\n\n      this.ctx1.translate(this.center[0], this.center[1]);\n      this.ctx2.translate(this.center[0], this.center[1]);\n      this.ctx3.translate(this.center[0], this.center[1]);\n\n      this.ctx1.scale(this.scale, -1 * this.scale);\n      this.ctx2.scale(this.scale, -1 * this.scale);\n      this.ctx3.scale(this.scale, -1 * this.scale);\n\n      // Tamanho do canvas em unidades já escaladas\n      this.width = this.canvas1.width / this.scale;\n    }\n  }, {\n    key: \"setCenter\",\n    value: function setCenter(center) {\n      this.ctx1.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx2.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx3.setTransform(1, 0, 0, 1, 0, 0);\n      this.center = center;\n      this.configure();\n      this.reset();\n    }\n  }, {\n    key: \"cleanAll\",\n    value: function cleanAll() {\n      this.ctx1.clearRect(this.canvas1.width * -1, this.canvas1.height * -1, this.canvas1.width * 2, this.canvas1.height * 2);\n      this.ctx2.clearRect(this.canvas1.width * -1, this.canvas1.height * -1, this.canvas1.width * 2, this.canvas1.height * 2);\n      this.ctx3.clearRect(this.canvas1.width * -1, this.canvas1.height * -1, this.canvas1.width * 2, this.canvas1.height * 2);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.cleanAll();\n      this.drawChart();\n    }\n  }, {\n    key: \"resetScale\",\n    value: function resetScale(scale) {\n      this.scale = scale;\n      this.configure();\n      this.reset();\n    }\n  }, {\n    key: \"clean\",\n    value: function clean(ctx) {\n      ctx.clearRect(this.canvas1.width * -1, this.canvas1.height * -1, this.canvas1.width * 2, this.canvas1.height * 2);\n    }\n  }, {\n    key: \"drawChart\",\n    value: function drawChart() {\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.center;\n\n\n      var spaceX = [(origin[0] - this.canvas1.width / 2) / this.scale, (origin[0] + this.canvas1.width / 2) / this.scale];\n      var spaceY = [(origin[1] - this.canvas1.height / 2) / this.scale, (origin[1] + this.canvas1.height / 2) / this.scale];\n\n      this.ctx1.lineWidth = 2 / this.scale;\n\n      for (var i = 0; i < this.width / 2; i = i + this.unityX) {\n\n        var color = i === this.center[0] ? \"#000\" : \"#CCC\";\n        // Linhas verticais\n        this.drawLine(this.ctx1, i * -1, spaceY[0], i * -1, spaceY[1], color);\n        this.drawLine(this.ctx1, i, spaceY[0], i, spaceY[1], color);\n\n        this.drawLine(this.ctx1, i, -0.1, i, 0.1, \"#000\");\n        this.drawLine(this.ctx1, i * -1, -0.1, i * -1, 0.1, \"#000\");\n      }\n\n      for (var _i = 0; _i < this.canvas1.height / this.scale / 2; _i = _i + this.unityY) {\n\n        var _color = _i === this.center[0] ? \"#000\" : \"#CCC\";\n        // Linhas horizontais\n        this.drawLine(this.ctx1, spaceX[0], _i * -1, spaceX[1], _i * -1, _color);\n        this.drawLine(this.ctx1, spaceX[0], _i, spaceX[1], _i, _color);\n\n        this.drawLine(this.ctx1, -0.1, _i, 0.1, _i, \"#000\");\n        this.drawLine(this.ctx1, -0.1, _i * -1, 0.1, _i * -1, \"#000\");\n      }\n\n      /* for (let i = 0; i < this.width; i++) {\r\n          let color = i === 0 ? \"#000\" : \"#CCC\";\r\n        // Linhas verticais\r\n        this.drawLine(this.ctx1, i * -1, this.width * -1, i * -1, this.width, color);\r\n        this.drawLine(this.ctx1, i, this.width * -1, i, this.width, color);\r\n          this.drawLine(this.ctx1, i, -0.1, i, 0.1, \"#000\");\r\n        this.drawLine(this.ctx1, i * -1, -0.1, i * -1, 0.1, \"#000\");\r\n          // Linhas horizontais\r\n        this.drawLine(this.ctx1, this.width * -1, i * -1, this.width, i * -1, color);\r\n        this.drawLine(this.ctx1, this.width * -1, i, this.width, i, color);\r\n          this.drawLine(this.ctx1, -0.1, i, 0.1, i, \"#000\");\r\n        this.drawLine(this.ctx1, -0.1, i * -1, 0.1, i * -1, \"#000\");\r\n      } */\n      this.ctx1.lineWidth = 4 / this.scale;\n    }\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(ctx, originX, originY, finalX, finalY, color) {\n      ctx.beginPath();\n      ctx.strokeStyle = color;\n      ctx.moveTo(originX, originY);\n      ctx.lineTo(finalX, finalY);\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(ctx, x, y, radius, color) {\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawText\",\n    value: function drawText(ctx, text, x, y) {\n      var newScale = 30;\n      ctx.scale(newScale / this.scale, -1 * newScale / this.scale);\n      ctx.fillText(text, x * this.scale / newScale, y * this.scale / (-1 * newScale));\n      ctx.scale(this.scale / newScale, this.scale / (-1 * newScale));\n    }\n  }]);\n\n  return Chart;\n}();\n\nexports.default = Chart;\n\n//# sourceURL=webpack:///./src/chart/chart.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _chart = __webpack_require__(/*! ./chart/chart */ \"./src/chart/chart.js\");\n\nvar _chart2 = _interopRequireDefault(_chart);\n\nvar _cyclicFormControl = __webpack_require__(/*! ./math/cyclic/cyclic-form-control */ \"./src/math/cyclic/cyclic-form-control.js\");\n\nvar _cyclicFormControl2 = _interopRequireDefault(_cyclicFormControl);\n\nvar _straightFormControl = __webpack_require__(/*! ./math/straight/straight-form-control */ \"./src/math/straight/straight-form-control.js\");\n\nvar _straightFormControl2 = _interopRequireDefault(_straightFormControl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar cyclicFormControl = new _cyclicFormControl2.default(document.getElementById(\"r1Cyc\"), document.getElementById(\"r2Cyc\"), document.getElementById(\"minAngleCyc\"), document.getElementById(\"maxAngleCyc\"), document.getElementById(\"typeCyc\"), new _chart2.default(document.getElementById(\"simpleCanvasContainer\")), document.getElementById(\"formCyc\"), document.getElementById(\"stopCyc\"), document.getElementById(\"continueCyc\"));\n\nvar straightFormControl = new _straightFormControl2.default(document.getElementById(\"rStr\"), document.getElementById(\"minAngleStr\"), document.getElementById(\"maxAngleStr\"), new _chart2.default(document.getElementById(\"cycloidCanvasContainer\")), document.getElementById(\"formStr\"), document.getElementById(\"stopStr\"), document.getElementById(\"continueStr\"));\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/math/basic-math-functions.js":
/*!******************************************!*\
  !*** ./src/math/basic-math-functions.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BasicMathFunctions = function () {\n  function BasicMathFunctions() {\n    _classCallCheck(this, BasicMathFunctions);\n  }\n\n  _createClass(BasicMathFunctions, [{\n    key: \"getAngleInRadians\",\n    value: function getAngleInRadians(angle) {\n      return angle * Math.PI / 180;\n    }\n  }, {\n    key: \"getAngleInDegrees\",\n    value: function getAngleInDegrees(angle) {\n      return angle * 180;\n    }\n  }, {\n    key: \"gcd\",\n    value: function gcd(n, m) {\n      var r = 0;\n      while (n !== 0) {\n        r = m % n;\n        m = n;\n        n = r;\n      }\n      return m;\n    }\n  }]);\n\n  return BasicMathFunctions;\n}();\n\nexports.default = BasicMathFunctions;\n\n//# sourceURL=webpack:///./src/math/basic-math-functions.js?");

/***/ }),

/***/ "./src/math/cyclic/cyclic-chart-control.js":
/*!*************************************************!*\
  !*** ./src/math/cyclic/cyclic-chart-control.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _epicycloid = __webpack_require__(/*! ./epicycloid */ \"./src/math/cyclic/epicycloid.js\");\n\nvar _epicycloid2 = _interopRequireDefault(_epicycloid);\n\nvar _hypocycloid = __webpack_require__(/*! ./hypocycloid */ \"./src/math/cyclic/hypocycloid.js\");\n\nvar _hypocycloid2 = _interopRequireDefault(_hypocycloid);\n\nvar _basicMathFunctions = __webpack_require__(/*! ./../basic-math-functions */ \"./src/math/basic-math-functions.js\");\n\nvar _basicMathFunctions2 = _interopRequireDefault(_basicMathFunctions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CyclicChartControl = function () {\n  function CyclicChartControl(R, r, minAngle, maxAngle, type, chart) {\n    _classCallCheck(this, CyclicChartControl);\n\n    this.R = parseFloat(R);\n    this.r = parseFloat(r);\n    this.minAngle = parseFloat(minAngle);\n    this.maxAngle = parseFloat(maxAngle);\n    this.type = type;\n    this.chart = chart;\n    this.epicycloid = new _epicycloid2.default(this.R, this.r);\n    this.hypocycloid = new _hypocycloid2.default(this.R, this.r);\n    this.counter = this.minAngle;\n    this.stop = false;\n\n    this.basicMathFunctions = new _basicMathFunctions2.default();\n\n    if (this.type === \"hypo\") {\n      this.chart.resetScale(200 / R);\n    } else {\n      this.chart.resetScale(180 / (this.R + this.r));\n    }\n\n    this.infoPos = [-1 * (this.chart.canvas1.width / 2 - 20) / this.chart.scale, (this.chart.canvas1.height / 2 - 40) / this.chart.scale];\n    this.chart.drawCircle(this.chart.ctx1, 0, 0, this.R, \"#337ab7\");\n    this.chart.drawText(this.chart.ctx1, \"R = \" + this.R, this.infoPos[0], this.infoPos[1]);\n    this.chart.drawText(this.chart.ctx1, \"r = \" + this.r, this.infoPos[0], this.infoPos[1] * 0.9);\n    this.chart.drawText(this.chart.ctx1, \"T = \" + (this.type === \"hypo\" ? this.hypocycloid.getPeriod() : this.epicycloid.getPeriod()), this.infoPos[0], this.infoPos[1] * 0.8);\n\n    this.drawCurve();\n  }\n\n  _createClass(CyclicChartControl, [{\n    key: \"drawMovingCircle\",\n    value: function drawMovingCircle(t, functionX, functionY) {\n      // Desenha o círculo em uma posição especificada\n\n      var diff = this.type === \"hypo\" ? this.R - this.r : this.R + this.r;\n\n      var posX = Math.cos(this.basicMathFunctions.getAngleInRadians(t)) * diff;\n      var posY = Math.sin(this.basicMathFunctions.getAngleInRadians(t)) * diff;\n      this.chart.clean(this.chart.ctx3);\n      this.chart.drawCircle(this.chart.ctx3, posX, posY, this.r, \"#000\");\n      this.chart.drawCircle(this.chart.ctx3, posX, posY, this.r / 15, \"#000\");\n      this.chart.drawCircle(this.chart.ctx3, functionX, functionY, this.r / 15, \"#d9534f\");\n      this.chart.drawLine(this.chart.ctx3, posX, posY, functionX, functionY, \"#000\");\n    }\n  }, {\n    key: \"drawCurve\",\n    value: function drawCurve() {\n      var _this = this;\n\n      // A verificação do stop também deve ocorrer aqui, pois a função \n      // drawCurve é chamada em mais de um lugar (redraw() e drawCurve())\n      if (this.stop) return;\n      if (!this.stop && this.counter === this.minAngle) this.chart.clean(this.chart.ctx2);\n      if (this.counter < this.maxAngle) {\n        this.counter++;\n        var originX = void 0,\n            originY = void 0,\n            futureX = void 0,\n            futureY = void 0;\n\n        if (this.type === \"hypo\") {\n          var _hypocycloid$get = this.hypocycloid.get(this.counter);\n\n          var _hypocycloid$get2 = _slicedToArray(_hypocycloid$get, 2);\n\n          originX = _hypocycloid$get2[0];\n          originY = _hypocycloid$get2[1];\n\n          var _hypocycloid$get3 = this.hypocycloid.get(this.counter + 1);\n\n          var _hypocycloid$get4 = _slicedToArray(_hypocycloid$get3, 2);\n\n          futureX = _hypocycloid$get4[0];\n          futureY = _hypocycloid$get4[1];\n        } else {\n          var _epicycloid$get = this.epicycloid.get(this.counter);\n\n          var _epicycloid$get2 = _slicedToArray(_epicycloid$get, 2);\n\n          originX = _epicycloid$get2[0];\n          originY = _epicycloid$get2[1];\n\n          var _epicycloid$get3 = this.epicycloid.get(this.counter + 1);\n\n          var _epicycloid$get4 = _slicedToArray(_epicycloid$get3, 2);\n\n          futureX = _epicycloid$get4[0];\n          futureY = _epicycloid$get4[1];\n        }\n\n        this.chart.drawLine(this.chart.ctx2, originX, originY, futureX, futureY, \"#d9534f\");\n        this.drawMovingCircle(this.counter, originX, originY);\n        this.chart.drawText(this.chart.ctx3, \"t = \" + this.counter + \"°\", this.infoPos[0], this.infoPos[1] * 0.7);\n        setTimeout(function () {\n          _this.drawCurve();\n        }, 14);\n      } else {\n        this.counter = this.minAngle;\n        setTimeout(function () {\n          _this.drawCurve();\n        }, 500);\n      }\n    }\n  }]);\n\n  return CyclicChartControl;\n}();\n\nexports.default = CyclicChartControl;\n\n//# sourceURL=webpack:///./src/math/cyclic/cyclic-chart-control.js?");

/***/ }),

/***/ "./src/math/cyclic/cyclic-cycloid.js":
/*!*******************************************!*\
  !*** ./src/math/cyclic/cyclic-cycloid.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _basicMathFunctions = __webpack_require__(/*! ./../basic-math-functions */ \"./src/math/basic-math-functions.js\");\n\nvar _basicMathFunctions2 = _interopRequireDefault(_basicMathFunctions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CyclicCycloid = function () {\n    function CyclicCycloid(R, r) {\n        _classCallCheck(this, CyclicCycloid);\n\n        this.basicMathFunctions = new _basicMathFunctions2.default();\n        this.R = R;\n        this.r = r;\n    }\n\n    _createClass(CyclicCycloid, [{\n        key: \"getPeriod\",\n        value: function getPeriod() {\n            var gcd = this.basicMathFunctions.gcd(this.r, this.R);\n            var p = this.r / gcd;\n            return (2 * p).toString() + \" PI\";\n        }\n    }]);\n\n    return CyclicCycloid;\n}();\n\nexports.default = CyclicCycloid;\n\n//# sourceURL=webpack:///./src/math/cyclic/cyclic-cycloid.js?");

/***/ }),

/***/ "./src/math/cyclic/cyclic-form-control.js":
/*!************************************************!*\
  !*** ./src/math/cyclic/cyclic-form-control.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _basicMathFunctions = __webpack_require__(/*! ./../basic-math-functions */ \"./src/math/basic-math-functions.js\");\n\nvar _basicMathFunctions2 = _interopRequireDefault(_basicMathFunctions);\n\nvar _cyclicChartControl = __webpack_require__(/*! ./cyclic-chart-control */ \"./src/math/cyclic/cyclic-chart-control.js\");\n\nvar _cyclicChartControl2 = _interopRequireDefault(_cyclicChartControl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CyclicFormControl = function () {\n  function CyclicFormControl(radius1Input, radius2Input, minAngleInput, maxAngleInput, typeInput, chart, form, continueButton, stopButton) {\n    var _this = this;\n\n    _classCallCheck(this, CyclicFormControl);\n\n    this.radius1Input = radius1Input;\n    this.radius2Input = radius2Input;\n    this.minAngleInput = minAngleInput;\n    this.maxAngleInput = maxAngleInput;\n    this.typeInput = typeInput;\n    this.basicMathFunctions = new _basicMathFunctions2.default();\n    this.chart = chart;\n    this.form = form;\n    this.continueButton = continueButton;\n    this.stopButton = stopButton;\n\n    this.chartControl = new _cyclicChartControl2.default(this.radius1Input.value, this.radius2Input.value, this.getAngle(this.minAngleInput.value), this.getAngle(this.maxAngleInput.value), this.typeInput.value, chart);\n\n    this.radius1Input.addEventListener(\"input\", function () {\n      return _this.validation();\n    });\n    this.radius2Input.addEventListener(\"input\", function () {\n      return _this.validation();\n    });\n    this.typeInput.addEventListener(\"input\", function () {\n      return _this.validation();\n    });\n    this.maxAngleInput.addEventListener(\"keyup\", function () {\n      return _this.validation();\n    });\n    this.minAngleInput.addEventListener(\"keyup\", function () {\n      return _this.validation();\n    });\n\n    this.form.addEventListener(\"submit\", function (event) {\n      event.preventDefault();\n      _this.update();\n      _this.continueButton.classList.add(\"hidden\");\n      _this.stopButton.classList.remove(\"hidden\");\n    });\n\n    this.stopButton.addEventListener(\"click\", function () {\n      _this.stop();\n      _this.continueButton.classList.remove(\"hidden\");\n      _this.stopButton.classList.add(\"hidden\");\n    });\n\n    this.continueButton.addEventListener(\"click\", function () {\n      _this.continue();\n      _this.continueButton.classList.add(\"hidden\");\n      _this.stopButton.classList.remove(\"hidden\");\n    });\n  }\n\n  _createClass(CyclicFormControl, [{\n    key: \"getAngle\",\n    value: function getAngle(angle) {\n      var angleInParts = angle.replace(\",\", \".\").split(\"/\");\n      if (angleInParts.length > 1) {\n        return this.basicMathFunctions.getAngleInDegrees(parseFloat(angleInParts[0]) / parseFloat(angleInParts[1]));\n      }\n      return this.basicMathFunctions.getAngleInDegrees(parseFloat(angleInParts[0]));\n    }\n  }, {\n    key: \"validation\",\n    value: function validation() {\n      this.radius2Input.setCustomValidity(\"\");\n      this.minAngleInput.setCustomValidity(\"\");\n      this.maxAngleInput.setCustomValidity(\"\");\n      if (parseFloat(this.radius1Input.value) <= parseFloat(this.radius2Input.value) && this.typeInput.value === \"hypo\") {\n        this.radius2Input.setCustomValidity(\"Raio inválido. Lembre que R > r\");\n        return false;\n      }\n      if (parseFloat(this.radius1Input.value) < this.radius2Input.value && parseFloat(this.typeInput.value) === \"epi\") {\n        this.radius2Input.setCustomValidity(\"Raio inválido. Lembre que R >= r\");\n        return false;\n      }\n      if (isNaN(this.getAngle(this.minAngleInput.value))) {\n        this.minAngleInput.setCustomValidity(\"Valor inválido. Insira somente números\");\n        return false;\n      }\n      if (isNaN(this.getAngle(this.maxAngleInput.value))) {\n        this.maxAngleInput.setCustomValidity(\"Valor inválido. Insira somente números\");\n        return false;\n      }\n      return true;\n    }\n\n    // Verifica se existe caso especial (Astroide, Cardioide e Deltoide)\n\n  }, {\n    key: \"checkSpecialCase\",\n    value: function checkSpecialCase() {\n      var specialCasesMessages = document.getElementsByClassName(\"special-case\");\n      for (var i = 0; i < specialCasesMessages.length; i++) {\n        specialCasesMessages[i].classList.add(\"hidden\");\n      }\n      if (this.typeInput.value === \"epi\") {\n        if (this.radius1Input.value === this.radius2Input.value) document.getElementById(\"cardioid-message\").classList.remove(\"hidden\");\n      } else {\n        if (this.radius1Input.value / this.radius2Input.value === 3) document.getElementById(\"deltoid-message\").classList.remove(\"hidden\");\n        if (this.radius1Input.value / this.radius2Input.value === 4) document.getElementById(\"astroid-message\").classList.remove(\"hidden\");\n      }\n    }\n\n    // Atualiza tudo com os valores informados\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.checkSpecialCase();\n      this.chartControl.stop = true;\n      this.chartControl = new _cyclicChartControl2.default(this.radius1Input.value, this.radius2Input.value, this.getAngle(this.minAngleInput.value), this.getAngle(this.maxAngleInput.value), this.typeInput.value, this.chart);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.chartControl.stop = true;\n    }\n  }, {\n    key: \"isStopped\",\n    value: function isStopped() {\n      return this.chartControl.stop;\n    }\n  }, {\n    key: \"continue\",\n    value: function _continue() {\n      this.chartControl.stop = false;\n      this.chartControl.drawCurve();\n    }\n  }]);\n\n  return CyclicFormControl;\n}();\n\nexports.default = CyclicFormControl;\n\n//# sourceURL=webpack:///./src/math/cyclic/cyclic-form-control.js?");

/***/ }),

/***/ "./src/math/cyclic/epicycloid.js":
/*!***************************************!*\
  !*** ./src/math/cyclic/epicycloid.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cyclicCycloid = __webpack_require__(/*! ./cyclic-cycloid */ \"./src/math/cyclic/cyclic-cycloid.js\");\n\nvar _cyclicCycloid2 = _interopRequireDefault(_cyclicCycloid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Epicycloid = function (_Cycloid) {\n    _inherits(Epicycloid, _Cycloid);\n\n    /* \n        * Quando o usuário quer que a circunferência com raio r <= R role \n        * pela parte externa da circunferência com raio R\n    */\n\n    function Epicycloid(R, r) {\n        _classCallCheck(this, Epicycloid);\n\n        return _possibleConstructorReturn(this, (Epicycloid.__proto__ || Object.getPrototypeOf(Epicycloid)).call(this, R, r));\n    }\n\n    _createClass(Epicycloid, [{\n        key: \"get\",\n        value: function get(t) {\n            return [(this.R + this.r) * Math.cos(this.basicMathFunctions.getAngleInRadians(t)) - this.r * Math.cos(this.basicMathFunctions.getAngleInRadians(this.R / this.r + 1) * t), (this.R + this.r) * Math.sin(this.basicMathFunctions.getAngleInRadians(t)) - this.r * Math.sin(this.basicMathFunctions.getAngleInRadians(this.R / this.r + 1) * t)];\n        }\n    }]);\n\n    return Epicycloid;\n}(_cyclicCycloid2.default);\n\nexports.default = Epicycloid;\n\n//# sourceURL=webpack:///./src/math/cyclic/epicycloid.js?");

/***/ }),

/***/ "./src/math/cyclic/hypocycloid.js":
/*!****************************************!*\
  !*** ./src/math/cyclic/hypocycloid.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cyclicCycloid = __webpack_require__(/*! ./cyclic-cycloid */ \"./src/math/cyclic/cyclic-cycloid.js\");\n\nvar _cyclicCycloid2 = _interopRequireDefault(_cyclicCycloid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Hypocycloid = function (_Cycloid) {\n    _inherits(Hypocycloid, _Cycloid);\n\n    /* \n        * Quando o usuário quer que a circunferência com raio r < R role \n        * pela parte interna da circunferência com raio R\n    */\n\n    function Hypocycloid(R, r) {\n        _classCallCheck(this, Hypocycloid);\n\n        return _possibleConstructorReturn(this, (Hypocycloid.__proto__ || Object.getPrototypeOf(Hypocycloid)).call(this, R, r));\n    }\n\n    _createClass(Hypocycloid, [{\n        key: \"get\",\n        value: function get(t) {\n            return [(this.R - this.r) * Math.cos(this.basicMathFunctions.getAngleInRadians(t)) + this.r * Math.cos(this.basicMathFunctions.getAngleInRadians(this.R / this.r - 1) * t), (this.R - this.r) * Math.sin(this.basicMathFunctions.getAngleInRadians(t)) - this.r * Math.sin(this.basicMathFunctions.getAngleInRadians(this.R / this.r - 1) * t)];\n        }\n    }]);\n\n    return Hypocycloid;\n}(_cyclicCycloid2.default);\n\nexports.default = Hypocycloid;\n\n//# sourceURL=webpack:///./src/math/cyclic/hypocycloid.js?");

/***/ }),

/***/ "./src/math/straight/straight-chart-control.js":
/*!*****************************************************!*\
  !*** ./src/math/straight/straight-chart-control.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _straightCycloid = __webpack_require__(/*! ./straight-cycloid */ \"./src/math/straight/straight-cycloid.js\");\n\nvar _straightCycloid2 = _interopRequireDefault(_straightCycloid);\n\nvar _basicMathFunctions = __webpack_require__(/*! ../basic-math-functions */ \"./src/math/basic-math-functions.js\");\n\nvar _basicMathFunctions2 = _interopRequireDefault(_basicMathFunctions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StraightChartControl = function () {\n    function StraightChartControl(r, minAngle, maxAngle, chart) {\n        _classCallCheck(this, StraightChartControl);\n\n        this.r = r;\n        this.minAngle = minAngle * Math.PI;\n        this.maxAngle = maxAngle * Math.PI;\n        this.chart = chart;\n\n        this.cycloid = new _straightCycloid2.default(this.r);\n\n        this.counter = this.minAngle;\n        this.stop = false;\n\n        this.delta = 0.05;\n\n        this.basicMathFunctions = new _basicMathFunctions2.default();\n\n        var rangeX = [this.cycloid.get(this.minAngle)[0], this.cycloid.get(this.maxAngle)[0]];\n        this.chart.scale = 100 / this.r;\n\n        var diffX = rangeX[1] - rangeX[0];\n\n        this.chart.setCenter([this.chart.parentDiv.offsetWidth * 0.75 - (rangeX[0] + diffX / 2) * this.chart.scale, this.chart.parentDiv.offsetHeight]);\n\n        this.infoPos = [(this.chart.canvas1.width - this.r * this.chart.scale * 3) / this.chart.scale, (this.chart.canvas1.height - 200) / this.chart.scale];\n        //this.chart.drawCircle(this.chart.ctx1, this.r, this.r, this.r, \"#337ab7\");\n        this.chart.drawText(this.chart.ctx1, \"r = \" + this.r, this.infoPos[0], this.infoPos[1]);\n\n        this.drawCurve();\n    }\n\n    _createClass(StraightChartControl, [{\n        key: \"drawMovingCircle\",\n        value: function drawMovingCircle(t, p) {\n            // Desenha o círculo em uma posição especificada p\n\n            this.chart.clean(this.chart.ctx3);\n            this.chart.drawCircle(this.chart.ctx3, p[0], p[1], this.r, \"#000\");\n            this.chart.drawCircle(this.chart.ctx3, p[0], p[1], this.r / 15, \"#000\");\n            this.chart.drawCircle(this.chart.ctx3, t[0], t[1], this.r / 15, \"#d9534f\");\n            this.chart.drawLine(this.chart.ctx3, p[0], p[1], t[0], t[1], \"#000\");\n        }\n    }, {\n        key: \"drawCurve\",\n        value: function drawCurve() {\n            var _this = this;\n\n            // A verificação do stop também deve ocorrer aqui, pois a função \n            // drawCurve é chamada em mais de um lugar (redraw() e drawCurve())\n            if (this.stop) return;\n            if (!this.stop && this.counter === this.minAngle) this.chart.clean(this.chart.ctx2);\n            if (this.counter <= this.maxAngle) {\n\n                var originX = void 0,\n                    originY = void 0,\n                    futureX = void 0,\n                    futureY = void 0;\n\n                var _cycloid$get = this.cycloid.get(this.counter);\n\n                var _cycloid$get2 = _slicedToArray(_cycloid$get, 2);\n\n                originX = _cycloid$get2[0];\n                originY = _cycloid$get2[1];\n\n                var _cycloid$get3 = this.cycloid.get(this.counter + this.delta);\n\n                var _cycloid$get4 = _slicedToArray(_cycloid$get3, 2);\n\n                futureX = _cycloid$get4[0];\n                futureY = _cycloid$get4[1];\n\n\n                this.chart.drawLine(this.chart.ctx2, originX, originY, futureX, futureY, \"#d9534f\");\n                this.drawMovingCircle([originX, originY], [this.counter * this.r, this.r]);\n                this.chart.drawText(this.chart.ctx3, \"t = \" + (originX / Math.PI).toFixed(2).toString() + \" π\", this.infoPos[0], this.infoPos[1] * 0.9);\n                this.counter += this.delta;\n                setTimeout(function () {\n                    _this.drawCurve();\n                }, 15);\n            } else {\n                this.counter = this.minAngle;\n                setTimeout(function () {\n                    _this.drawCurve();\n                }, 500);\n            }\n        }\n    }]);\n\n    return StraightChartControl;\n}();\n\nexports.default = StraightChartControl;\n\n//# sourceURL=webpack:///./src/math/straight/straight-chart-control.js?");

/***/ }),

/***/ "./src/math/straight/straight-cycloid.js":
/*!***********************************************!*\
  !*** ./src/math/straight/straight-cycloid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StraightCycloid = function () {\n    function StraightCycloid(r) {\n        _classCallCheck(this, StraightCycloid);\n\n        this.r = r;\n    }\n\n    _createClass(StraightCycloid, [{\n        key: \"get\",\n        value: function get(t) {\n            return [this.r * (t - Math.sin(t)), this.r * (1 - Math.cos(t))];\n        }\n    }]);\n\n    return StraightCycloid;\n}();\n\nexports.default = StraightCycloid;\n\n//# sourceURL=webpack:///./src/math/straight/straight-cycloid.js?");

/***/ }),

/***/ "./src/math/straight/straight-form-control.js":
/*!****************************************************!*\
  !*** ./src/math/straight/straight-form-control.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _basicMathFunctions = __webpack_require__(/*! ./../basic-math-functions */ \"./src/math/basic-math-functions.js\");\n\nvar _basicMathFunctions2 = _interopRequireDefault(_basicMathFunctions);\n\nvar _straightChartControl = __webpack_require__(/*! ./straight-chart-control */ \"./src/math/straight/straight-chart-control.js\");\n\nvar _straightChartControl2 = _interopRequireDefault(_straightChartControl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StraightFormControl = function () {\n    function StraightFormControl(radiusInput, minAngleInput, maxAngleInput, chart, form, stopButton, continueButton) {\n        var _this = this;\n\n        _classCallCheck(this, StraightFormControl);\n\n        this.radiusInput = radiusInput;\n        this.minAngleInput = minAngleInput;\n        this.maxAngleInput = maxAngleInput;\n        this.chart = chart;\n        this.form = form;\n        this.stopButton = stopButton;\n        this.continueButton = continueButton;\n        this.basicMathFunctions = new _basicMathFunctions2.default();\n\n        this.chartControl = new _straightChartControl2.default(this.radiusInput.value, this.getAngle(this.minAngleInput.value), this.getAngle(this.maxAngleInput.value), chart);\n\n        this.maxAngleInput.addEventListener(\"keyup\", function () {\n            return _this.validation();\n        });\n        this.minAngleInput.addEventListener(\"keyup\", function () {\n            return _this.validation();\n        });\n\n        this.form.addEventListener(\"submit\", function (event) {\n            event.preventDefault();\n            _this.update();\n            _this.continueButton.classList.add(\"hidden\");\n            _this.stopButton.classList.remove(\"hidden\");\n        });\n\n        continueButton.addEventListener(\"click\", function () {\n            _this.continue();\n            _this.continueButton.classList.add(\"hidden\");\n            _this.stopButton.classList.remove(\"hidden\");\n        });\n\n        stopButton.addEventListener(\"click\", function () {\n            _this.stop();\n            _this.continueButton.classList.remove(\"hidden\");\n            _this.stopButton.classList.add(\"hidden\");\n        });\n    }\n\n    _createClass(StraightFormControl, [{\n        key: \"getAngle\",\n        value: function getAngle(angle) {\n            var angleInParts = angle.replace(\",\", \".\").split(\"/\");\n            if (angleInParts.length > 1) {\n                return parseFloat(angleInParts[0] / parseFloat(angleInParts[1]));\n            }\n            return parseFloat(angleInParts[0]);\n        }\n    }, {\n        key: \"stop\",\n        value: function stop() {\n            this.chartControl.stop = true;\n        }\n    }, {\n        key: \"validation\",\n        value: function validation() {\n            this.radiusInput.setCustomValidity(\"\");\n            this.minAngleInput.setCustomValidity(\"\");\n            this.maxAngleInput.setCustomValidity(\"\");\n            if (parseFloat(this.minAngleInput.value) >= parseFloat(this.maxAngleInput.value)) {\n                this.maxAngleInput.setCustomValidity(\"Valores inválidos\");\n                return false;\n            }\n            if (parseFloat(this.radiusInput.value) <= 0) {\n                this.radiusInput.setCustomValidity(\"Raio inválido. Lembre que r > 0\");\n                return false;\n            }\n            return true;\n        }\n\n        // Atualiza tudo com os valores informados\n\n    }, {\n        key: \"update\",\n        value: function update() {\n            this.chartControl.stop = true;\n            this.chartControl = new _straightChartControl2.default(this.radiusInput.value, this.getAngle(this.minAngleInput.value), this.getAngle(this.maxAngleInput.value), this.chart);\n        }\n    }, {\n        key: \"isStopped\",\n        value: function isStopped() {\n            return this.chartControl.stop;\n        }\n    }, {\n        key: \"continue\",\n        value: function _continue() {\n            this.chartControl.stop = false;\n            this.chartControl.drawCurve();\n        }\n    }]);\n\n    return StraightFormControl;\n}();\n\nexports.default = StraightFormControl;\n\n//# sourceURL=webpack:///./src/math/straight/straight-form-control.js?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/index.js?");

/***/ })

/******/ });